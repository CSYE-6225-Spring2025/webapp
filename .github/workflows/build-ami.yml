name: Build and Deploy AMI

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    name: Run integration test
    runs-on: ubuntu-latest
    env:
      SPRING_DATASOURCE_USERNAME: ${{ secrets.SPRING_DATASOURCE_USERNAME }}
      SPRING_DATASOURCE_PASSWORD: ${{ secrets.SPRING_DATASOURCE_PASSWORD }}
      DB_USERNAME: ${{ secrets.DB_USERNAME }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      DB_HOST: ${{ secrets.DB_HOST }}
      DB_NAME: ${{ secrets.DB_NAME }}
      AWS_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY }}
      AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_USERNAME : ${{ secrets.DB_USERNAME }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.DB_PASSWORD }}
          MYSQL_DATABASE: health_check
        ports:
          - 3306:3306

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Run Tests
        run: mvn clean test

      - name: Build JAR
        run: mvn clean package -DskipTests

      - name: Upload JAR Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/*.jar

  build-ami:
    name: build AMI image
    needs: build
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download JAR Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target/

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: "${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}"

      - name: Create JSON File from Secret
        run: |
          echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' | jq '.' > secret.json

      - name: Initialize Packer (Install Plugins)
        run: packer init aws.pkr.hcl

      - name: Create Packer Variable File
        run: |
          cat <<EOF > auto.pkrvars.hcl
          aws_region    = "${{ secrets.AWS_REGION }}"
          gcp_demo_account = "${{ secrets.GCP_DEMO_ACCOUNT }}"
          gcp_source_image = "${{ secrets.GCP_SOURCE_IMAGE }}"
          gcp_source_image_family = "${{ secrets.GCP_SOURCE_IMAGE_FAMILY }}"
          gcp_machine_type = "${{ secrets.GCP_MACHINE_TYPE }}"
          gcp_disk_type = "${{ secrets.GCP_DISK_TYPE }}"
          gcp_network = "${{ secrets.GCP_NETWORK }}"
          gcp_image_description = "${{ secrets.GCP_IMAGE_DESCRIPTION }}"
          gcp_image_name = "${{ secrets.GCP_IMAGE_NAME }}"
          instance_type = "${{ secrets.INSTANCE_TYPE }}"
          accounts      =  ${{ secrets.AWS_ACCOUNTS }}
          ami_name_prefix = "${{ secrets.AMI_NAME_PREFIX }}"
          user_name     = "${{ secrets.USER_NAME }}"
          group_name    = "${{ secrets.GROUP_NAME }}"
          ssh_username  = "${{ secrets.SSH_USERNAME }}"
          PACKER_DB_USERNAME = "${{ secrets.PACKER_DB_USERNAME }}"
          PACKER_DB_PASSWORD = "${{ secrets.PACKER_DB_PASSWORD }}"
          gcp_project_id = "${{ secrets.GCP_PROJECT_ID }}"
          gcp_zone      = "${{ secrets.GCP_ZONE }}"
          credentials_file  = "secret.json"
          
          EOF

      - name: Extract AMI ID from Packer Output
        id: get-ami-id
        run: |
          AMI_ID=$(packer build -machine-readable -var-file=auto.pkrvars.hcl aws.pkr.hcl | tee packer-output.log | grep 'artifact,0,id' | cut -d, -f6 | cut -d: -f2)
          echo "AMI_ID=$AMI_ID" >> $GITHUB_OUTPUT

      - name: Configure AWS CLI for DEMO Account
        run: |
          aws configure set aws_access_key_id "${{ secrets.DEMO_AWS_ACCESS_KEY_ID }}"
          aws configure set aws_secret_access_key "${{ secrets.DEMO_AWS_SECRET_ACCESS_KEY }}"
          aws configure set region "${{ secrets.AWS_REGION }}" 

      - name: Debug Launch Template Name
        run: |
          echo "LT name: ${{ secrets.LAUNCH_TEMPLATE_NAME }}"

      - name: Create New Launch Template Version
        id: lt-version
        run: |
          VERSION=$(aws ec2 create-launch-template-version \
            --launch-template-name "webapp-lt-aws-v120250409225953994200000006" \
            --source-version "\$Latest" \
            --version-description "From GitHub Actions - ${{ github.sha }}" \
            --launch-template-data "{\"ImageId\":\"${{ steps.get-ami-id.outputs.AMI_ID }}\"}" \
            --query 'LaunchTemplateVersion.VersionNumber' \
            --output text)
          echo "VERSION=$VERSION" >> $GITHUB_OUTPUT

      - name: Update Auto Scaling Group with New Launch Template Version
        run: |
          aws autoscaling update-auto-scaling-group \
            --auto-scaling-group-name "${{ secrets.ASG_NAME }}" \
            --launch-template "LaunchTemplateName=webapp-lt-aws-v120250409225953994200000006,Version=${{ steps.lt-version.outputs.VERSION }}"

      - name: Start Instance Refresh
        id: refresh
        run: |
          INSTANCE_REFRESH_ID=$(aws autoscaling start-instance-refresh \
            --auto-scaling-group-name "${{ secrets.ASG_NAME }}" \
            --strategy Rolling \
            --query 'InstanceRefreshId' --output text)
          echo "INSTANCE_REFRESH_ID=$INSTANCE_REFRESH_ID" >> $GITHUB_OUTPUT


      - name: Wait for Instance Refresh to Complete
        run: |
          STATUS="InProgress"
          while [ "$STATUS" == "InProgress" ]; do
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name "${{ secrets.ASG_NAME }}" \
              --instance-refresh-ids "${{ steps.refresh.outputs.INSTANCE_REFRESH_ID }}" \
              --query 'InstanceRefreshes[0].Status' \
              --output text)
            echo "Current status: $STATUS"
            sleep 20
          done

          if [ "$STATUS" != "Successful" ]; then
            echo "❌ Instance refresh failed or was cancelled. Status: $STATUS"
            exit 1
          else
            echo "✅ Instance refresh completed successfully."
          fi



