name: Build and Deploy AMI

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  build:
    name: Run integration test
    runs-on: ubuntu-latest
    env:
      SPRING_DATASOURCE_USERNAME: ${{ secrets.SPRING_DATASOURCE_USERNAME }}
      SPRING_DATASOURCE_PASSWORD: ${{ secrets.SPRING_DATASOURCE_PASSWORD }}
      DB_USERNAME: ${{ secrets.DB_USERNAME }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      DB_HOST: ${{ secrets.DB_HOST }}
      DB_NAME: ${{ secrets.DB_NAME }}
      AWS_ACCESS_KEY: ${{ secrets.AWS_ACCESS_KEY }}
      AWS_SECRET_KEY: ${{ secrets.AWS_SECRET_KEY }}
      AWS_REGION: ${{ secrets.AWS_REGION }}
      AWS_S3_BUCKET_NAME: ${{ secrets.AWS_S3_BUCKET_NAME }}

    services:
      mysql:
        image: mysql:8.0
        env:
          MYSQL_ROOT_USERNAME : ${{ secrets.DB_USERNAME }}
          MYSQL_ROOT_PASSWORD: ${{ secrets.DB_PASSWORD }}
          MYSQL_DATABASE: health_check
        ports:
          - 3306:3306

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v3

      - name: Set up JDK 17
        uses: actions/setup-java@v3
        with:
          java-version: '17'
          distribution: 'temurin'

      - name: Run Tests
        run: mvn clean test

      - name: Build JAR
        run: mvn clean package -DskipTests

      - name: Upload JAR Artifact
        uses: actions/upload-artifact@v4
        with:
          name: app-jar
          path: target/*.jar

  build-ami:
    name: build AMI image
    needs: build
    runs-on: ubuntu-latest
    outputs:
      ami_id: ${{ steps.extract_ami.outputs.ami_id }}

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Download JAR Artifact
        uses: actions/download-artifact@v4
        with:
          name: app-jar
          path: target/

      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: us-east-1

      - name: Authenticate with Google Cloud
        uses: google-github-actions/auth@v2
        with:
          credentials_json: "${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}"

      - name: Create JSON File from Secret
        run: |
          echo '${{ secrets.GCP_SERVICE_ACCOUNT_KEY }}' | jq '.' > secret.json

      - name: Initialize Packer (Install Plugins)
        run: packer init aws.pkr.hcl

      - name: Create Packer Variable File
        run: |
          cat <<EOF > auto.pkrvars.hcl
          aws_region    = "${{ secrets.AWS_REGION }}"
          gcp_demo_account = "${{ secrets.GCP_DEMO_ACCOUNT }}"
          gcp_source_image = "${{ secrets.GCP_SOURCE_IMAGE }}"
          gcp_source_image_family = "${{ secrets.GCP_SOURCE_IMAGE_FAMILY }}"
          gcp_machine_type = "${{ secrets.GCP_MACHINE_TYPE }}"
          gcp_disk_type = "${{ secrets.GCP_DISK_TYPE }}"
          gcp_network = "${{ secrets.GCP_NETWORK }}"
          gcp_image_description = "${{ secrets.GCP_IMAGE_DESCRIPTION }}"
          gcp_image_name = "${{ secrets.GCP_IMAGE_NAME }}"
          instance_type = "${{ secrets.INSTANCE_TYPE }}"
          accounts      =  ${{ secrets.AWS_ACCOUNTS }}
          ami_name_prefix = "${{ secrets.AMI_NAME_PREFIX }}"
          user_name     = "${{ secrets.USER_NAME }}"
          group_name    = "${{ secrets.GROUP_NAME }}"
          ssh_username  = "${{ secrets.SSH_USERNAME }}"
          PACKER_DB_USERNAME = "${{ secrets.PACKER_DB_USERNAME }}"
          PACKER_DB_PASSWORD = "${{ secrets.PACKER_DB_PASSWORD }}"
          gcp_project_id = "${{ secrets.GCP_PROJECT_ID }}"
          gcp_zone      = "${{ secrets.GCP_ZONE }}"
          credentials_file  = "secret.json"
          
          EOF

      - name: Build AMI with Packer
        run: |
          packer build -machine-readable -var-file=auto.pkrvars.hcl aws.pkr.hcl | tee packer-output.log

      - name: Extract AMI ID from Packer Output
        id: extract_ami
        run: |
          # Extracts the latest AMI ID from Packer output using regex
          AMI_ID=$(grep -oP 'ami-[a-f0-9]+' packer-output.log | tail -1)

          # Check if AMI_ID was found
          if [ -z "$AMI_ID" ]; then
            echo "❌ Error: AMI_ID is empty. Check packer_output.log." >&2
            exit 1
          fi

          # Log the extracted AMI ID
          echo "✅ Extracted AMI_ID: $AMI_ID"

          # Set AMI ID as a GitHub Actions output
          echo "ami_id=$AMI_ID" >> $GITHUB_OUTPUT
      

  deploy:
    name: Deploy New AMI to ASG
    needs: build-ami
    runs-on: ubuntu-latest
    env:
      ASG_NAME: ${{ secrets.ASG_NAME }}
      LAUNCH_TEMPLATE_NAME: ${{ secrets.LAUNCH_TEMPLATE_NAME }}
      AMI_ID: ${{ needs.build-ami.outputs.ami_id }}

    steps:
      - name: Configure AWS CLI for DEMO Account
        run: |
          aws configure set aws_access_key_id "${{ secrets.DEMO_AWS_ACCESS_KEY_ID }}"
          aws configure set aws_secret_access_key "${{ secrets.DEMO_AWS_SECRET_ACCESS_KEY }}"
          aws configure set region "${{ secrets.AWS_REGION }}" 

      - name: Debug Launch Template Name
        run: |
          echo "LT name: $LAUNCH_TEMPLATE_NAME"

      - name: Create New Launch Template Version
        id: create_lt_version
        run: |
            echo "Creating new launch template version with AMI ${{ env.AMI_ID }}..."
            NEW_LT_VERSION=$(aws ec2 create-launch-template-version \
              --launch-template-name $LAUNCH_TEMPLATE_NAME \
              --source-version '$Latest' \
              --launch-template-data "{\"ImageId\":\"${{ env.AMI_ID }}\"}" \
              --query 'LaunchTemplateVersion.VersionNumber' --output text)
            echo "New launch template version: $NEW_LT_VERSION"
            echo "lt_version=$NEW_LT_VERSION" >> $GITHUB_OUTPUT

      - name: Update Auto Scaling Group to Use New Launch Template Version
        run: |
            aws autoscaling update-auto-scaling-group \
              --auto-scaling-group-name $ASG_NAME \
              --launch-template "LaunchTemplateName=$LAUNCH_TEMPLATE_NAME,Version=${{ steps.create_lt_version.outputs.lt_version }}"

      - name: Start Instance Refresh on ASG
        id: start_instance_refresh
        run: |
            REFRESH_ID=$(aws autoscaling start-instance-refresh \
              --auto-scaling-group-name $ASG_NAME \
              --preferences '{"MinHealthyPercentage":90,"InstanceWarmup":60}' \
              --query 'InstanceRefreshId' --output text)
            echo "Instance refresh initiated with ID: $REFRESH_ID"
            echo "refresh_id=$REFRESH_ID" >> $GITHUB_OUTPUT

      - name: Wait for Instance Refresh to Complete
        run: |
            REFRESH_ID=${{ steps.start_instance_refresh.outputs.refresh_id }}
            echo "Waiting for instance refresh with ID: $REFRESH_ID to complete..."
            STATUS=$(aws autoscaling describe-instance-refreshes \
              --auto-scaling-group-name $ASG_NAME \
              --query "InstanceRefreshes[?InstanceRefreshId=='$REFRESH_ID'].Status" --output text)
            echo "Initial refresh status: $STATUS"
            while [[ "$STATUS" != "Successful" && "$STATUS" != "Failed" ]]; do
              sleep 30
              STATUS=$(aws autoscaling describe-instance-refreshes \
                --auto-scaling-group-name $ASG_NAME \
                --query "InstanceRefreshes[?InstanceRefreshId=='$REFRESH_ID'].Status" --output text)
              echo "Current refresh status: $STATUS"
            done
            echo "Final instance refresh status: $STATUS"
            if [ "$STATUS" != "Successful" ]; then
              echo "Instance refresh failed!"
              exit 1
            fi